# Nanobot v0.3.0 升级计划

## 1. 升级概述

### 1.1 目标版本
**v0.3.0** - 持续工作与记忆系统升级

### 1.2 升级主题
- **持续工作机制**：实现 OpenClaw 式的 Heartbeat + Cron Job 协作机制
- **记忆系统重构**：建立三层记忆架构（L1/L2/L3）
- **技能系统优化**：设计可扩展的技能架构
- **渐进式披露**：实现文件管理的渐进式披露机制

### 1.3 预计工期
**14 天**（2026-02-13 至 2026-02-26）

### 1.4 开发环境
- **Python**：3.13
- **虚拟环境**：temp_venv
- **项目路径**：/Users/jiangyayun/develop/code/work_code/nanobot
- **Git 分支**：feature/v0.3.0

## 2. 升级目标

### 2.1 核心目标
1. 实现 24 小时持续工作机制（Heartbeat + Cron Job）
2. 重构记忆系统，建立三层架构
3. 优化技能系统，提高可扩展性
4. 实现渐进式披露的文件管理

### 2.2 具体目标

#### 持续工作机制
- 实现 Heartbeat 定期轮询（10-15 分钟）
- 设计轮换检查规则
- 实现条件触发和实时监控
- 添加 Cron Job 精确时间任务

#### 记忆系统
- 实现三层记忆架构（L1/L2/L3）
- 添加语义搜索功能
- 支持渐进式披露
- 优化记忆存储和检索

#### 技能系统
- 设计可扩展的技能架构
- 实现技能市场支持
- 优化技能加载和执行机制
- 添加技能使用统计

#### 文件管理
- 实现渐进式披露机制
- 优化文件结构和访问方式
- 添加内容压缩和索引功能

## 3. 技术方案

### 3.1 持续工作机制架构

#### Heartbeat 系统
```python
# nanobot/heartbeat/heartbeat_manager.py

class HeartbeatManager:
    """心跳管理器"""
    
    def __init__(self):
        self.rotation_index = 0
        self.last_check_time = None
        self.check_status = {}
    
    def run_heartbeat(self):
        """执行一次心跳检查"""
        # 读取状态文件
        state = self._read_heartbeat_state()
        
        # 执行轮换检查
        self._execute_rotation_check(state)
        
        # 日常分析和技能优化
        self._daily_analysis()
        
        # 更新状态
        self._update_heartbeat_state(state)
        
        return "HEARTBEAT_OK"
    
    def _execute_rotation_check(self, state):
        """执行轮换检查"""
        checks = [
            self._check_tasks,
            self._check_channels,
            self._check_skills,
            self._check_system
        ]
        
        check_func = checks[state["rotationIndex"]]
        check_func()
        
        # 更新轮换索引
        state["rotationIndex"] = (state["rotationIndex"] + 1) % len(checks)
```

#### Cron Job 系统
```python
# nanobot/cron/cron_manager.py

class CronManager:
    """定时任务管理器"""
    
    def __init__(self):
        self.jobs = self._load_cron_jobs()
    
    def run_scheduled_jobs(self):
        """运行到期的定时任务"""
        now = datetime.now()
        
        for job in self.jobs:
            if job.is_due(now):
                self._execute_job(job)
    
    def _execute_job(self, job):
        """执行定时任务"""
        # 检查执行环境
        if job.needs_isolation():
            self._execute_in_isolated_session(job)
        else:
            self._execute_in_main_session(job)
    
    def _load_cron_jobs(self):
        """加载 Cron 任务配置"""
        config_path = config.get_cron_jobs_config()
        with open(config_path, 'r', encoding='utf-8') as f:
            jobs = json.load(f)
        
        return [CronJob.from_dict(job) for job in jobs]
```

### 3.2 记忆系统架构

#### 三层记忆结构
```python
# nanobot/memory/memory_manager.py

class MemoryManager:
    """记忆管理器"""
    
    def __init__(self):
        self.l1_memory = L1Memory()  # 会话记忆（内存）
        self.l2_memory = L2Memory()  # 中期记忆（文件）
        self.l3_memory = L3Memory()  # 长期记忆（数据库）
    
    def search_memory(self, query: str, layer: str = "all") -> list:
        """语义搜索记忆"""
        # 使用火山引擎 API 进行语义搜索
        pass
    
    def get_memory(self, reference: str) -> str:
        """获取记忆片段"""
        if reference.startswith("memory/"):
            return self.l2_memory.get(reference)
        elif reference == "MEMORY.md":
            return self.l3_memory.get()
        else:
            return self.l1_memory.get(reference)
    
    def save_memory(self, content: str, layer: str = "L2") -> str:
        """保存记忆"""
        if layer == "L1":
            return self.l1_memory.save(content)
        elif layer == "L2":
            return self.l2_memory.save(content)
        elif layer == "L3":
            return self.l3_memory.save(content)
```

#### 记忆存储接口
```python
# nanobot/memory/layered_memory.py

class L1Memory:
    """L1 会话记忆（内存）"""
    
    def __init__(self):
        self.memory = {}
    
    def save(self, key: str, content: str):
        self.memory[key] = content
    
    def get(self, key: str) -> str:
        return self.memory.get(key, "")


class L2Memory:
    """L2 中期记忆（文件系统）"""
    
    def __init__(self):
        self.base_path = os.path.expanduser("~/.nanobot/memory")
        os.makedirs(self.base_path, exist_ok=True)
    
    def save(self, content: str) -> str:
        today = datetime.now().strftime("%Y-%m-%d")
        file_path = os.path.join(self.base_path, f"{today}.md")
        
        with open(file_path, "a", encoding="utf-8") as f:
            f.write(f"\n\n## {datetime.now().strftime('%H:%M:%S')}\n{content}")
        
        return file_path
    
    def get(self, reference: str) -> str:
        file_path = os.path.expanduser(f"~/.nanobot/{reference}")
        
        if os.path.exists(file_path):
            with open(file_path, "r", encoding="utf-8") as f:
                return f.read()
        
        return ""


class L3Memory:
    """L3 长期记忆（结构化存储）"""
    
    def __init__(self):
        self.db_path = os.path.expanduser("~/.nanobot/memory.db")
    
    def save(self, content: str):
        # 这里应该使用更复杂的存储方案，如 SQLite 或矢量数据库
        pass
    
    def get(self) -> str:
        # 读取长期记忆
        pass
```

### 3.3 技能系统架构

#### 技能加载器
```python
# nanobot/skills/skill_manager.py

class SkillManager:
    """技能管理器"""
    
    def __init__(self):
        self.skills = {}
        self.skill_paths = [
            os.path.expanduser("~/.nanobot/skills"),
            os.path.expanduser("~/.openclaw/workspace/skills")
        ]
    
    def load_skills(self):
        """加载所有可用技能"""
        for path in self.skill_paths:
            if os.path.exists(path):
                self._load_skills_from_dir(path)
    
    def _load_skills_from_dir(self, directory: str):
        """从目录加载技能"""
        for filename in os.listdir(directory):
            if filename.endswith(".py") and not filename.startswith("_"):
                try:
                    module_name = f"skills.{filename[:-3]}"
                    module = importlib.import_module(module_name)
                    
                    if hasattr(module, "register_skills"):
                        module.register_skills(self)
                except Exception as e:
                    logger.error(f"Failed to load skill {filename}: {e}")
```

## 4. 实施步骤

### 阶段 0：准备阶段（1 天）
1. 环境准备和依赖安装
2. 项目结构调整
3. 创建 feature/v0.3.0 分支

### 阶段 1：持续工作机制（3 天）
1. 实现 Heartbeat 管理器
2. 实现 Cron Job 管理器
3. 实现心跳状态管理
4. 测试持续工作机制

### 阶段 2：记忆系统重构（3 天）
1. 实现三层记忆架构
2. 实现记忆存储接口
3. 实现语义搜索功能
4. 测试记忆系统

### 阶段 3：技能系统优化（2 天）
1. 实现技能管理器
2. 优化技能加载和执行
3. 添加技能使用统计
4. 测试技能系统

### 阶段 4：文件管理优化（1 天）
1. 实现渐进式披露机制
2. 优化文件结构
3. 实现内容压缩
4. 测试文件管理

### 阶段 5：集成测试（2 天）
1. 功能测试
2. 性能测试
3. 稳定性测试
4. 代码质量检查

### 阶段 6：收尾工作（2 天）
1. 修复测试收集错误
2. 推送 Git 提交
3. 更新项目文档
4. 创建 CHANGELOG.md

## 5. 风险评估和缓解措施

| 风险 | 发生概率 | 影响程度 | 缓解措施 |
|------|----------|----------|----------|
| 技术架构复杂 | 中 | 高 | 分阶段实施，每个阶段完成后测试 |
| 记忆系统性能 | 中 | 中 | 使用索引和缓存优化检索 |
| 技能兼容性问题 | 低 | 中 | 提供技能迁移工具 |
| 测试覆盖不足 | 低 | 中 | 增加单元测试和集成测试 |
| 项目进度延迟 | 中 | 中 | 定期进度跟踪，及时调整计划 |

## 6. 验收标准

### 6.1 功能验收

| 功能 | 验收标准 | 测试方法 |
|------|----------|----------|
| **持续工作机制** | 心跳检查每 10-15 分钟执行，支持轮换检查 | 启动服务后观察日志 |
| **定时任务** | 支持 Cron 表达式，可精确执行任务 | 配置简单定时任务测试 |
| **记忆系统** | 支持三层记忆存储和语义搜索 | 测试记忆的读写和搜索 |
| **技能系统** | 支持技能市场和工作区技能 | 测试技能的加载和执行 |
| **渐进式披露** | 主文件存储概要，详细信息按需读取 | 测试文件访问和内容压缩 |

### 6.2 性能验收

| 指标 | 目标值 | 测试方法 |
|------|----------|----------|
| **心跳响应时间** | < 5 秒 | 测量多次心跳检查时间 |
| **记忆检索时间** | < 3 秒 | 测试 1000+ 条记录的搜索 |
| **技能加载时间** | < 2 秒 | 测试 50+ 技能的加载 |
| **系统资源占用** | CPU < 50%，内存 < 2GB | 监控系统资源使用 |

### 6.3 稳定性验收

| 指标 | 目标值 | 测试方法 |
|------|----------|----------|
| **服务持续运行时间** | > 7 天无重启 | 长时间运行测试 |
| **错误率** | < 1% | 统计执行失败的次数 |
| **恢复能力** | 错误后自动恢复 | 故意触发错误后观察恢复情况 |

## 7. 相关文档

- **架构设计**: `ARCHITECTURE-v0.3.0.md`
- **变更日志**: `CHANGELOG.md`
- **升级指南**: `UPGRADE-GUIDE-v0.3.0.md`
- **API 文档**: `API-DOCS-v0.3.0.md`

## 8. 发布计划

| 阶段 | 预计完成时间 | 交付内容 |
|------|----------|----------|
| 开发完成 | 2026-02-23 | 完整代码实现 |
| 测试完成 | 2026-02-24 | 测试报告和修复 |
| 文档更新 | 2026-02-25 | 所有文档完成 |
| 正式发布 | 2026-02-26 | 可部署版本 |

---

**文档创建时间**: 2026-02-12  
**最后更新时间**: 2026-02-12  
**版本**: v0.1
