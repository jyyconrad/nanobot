# æ„å›¾è¯†åˆ«ç³»ç»Ÿå‡çº§æ–¹æ¡ˆ

## ğŸ“‹ ç°çŠ¶åˆ†æ

### å½“å‰é—®é¢˜

1. **å•ä¸€å›ºå®šè§„åˆ™**
   - ç°åœ¨çš„æŒ‡ä»¤ä½“ç³»å®Œå…¨åŸºäºå›ºå®šè§„åˆ™åŒ¹é…
   - ç”¨æˆ·è¾“å…¥æ„å›¾åˆ†æä¹Ÿæ˜¯ç®€å•çš„å…³é”®è¯åŒ¹é…
   - æ— æ³•å¤„ç†å¤æ‚ã€æ¨¡ç³Šã€å¤šæ„å›¾çš„åœºæ™¯

2. **ç¼ºä¹çµæ´»æ€§**
   - æ–°å¢æŒ‡ä»¤éœ€è¦ä¿®æ”¹ä»£ç 
   - æ— æ³•åŠ¨æ€è°ƒæ•´æ„å›¾è¯†åˆ«ç­–ç•¥
   - æ‰©å±•æ€§å·®

3. **å‡†ç¡®ç‡å—é™**
   - çº¯è§„åˆ™åŒ¹é…æ— æ³•ç†è§£è¯­ä¹‰
   - åŒä¹‰è¯ã€å˜ä½“æ— æ³•è¯†åˆ«
   - ä¸Šä¸‹æ–‡ç†è§£èƒ½åŠ›å¼±

---

## ğŸ¯ å‡çº§ç›®æ ‡

è®¾è®¡ä¸€ä¸ª**æ··åˆå¼æ„å›¾è¯†åˆ«ç³»ç»Ÿ**ï¼Œç»“åˆä¸‰ç§æ–¹å¼ï¼š

1. **å›ºå®šæ¨¡å¼ï¼ˆRule-basedï¼‰** - å¿«é€Ÿã€å‡†ç¡®ã€é«˜æ•ˆ
2. **ä»£ç å¤„ç†ï¼ˆCode-basedï¼‰** - å¤æ‚é€»è¾‘ã€çŠ¶æ€ä¾èµ–
3. **å¤§æ¨¡å‹è¯†åˆ«ï¼ˆLLM-basedï¼‰** - è¯­ä¹‰ç†è§£ã€æ¨¡ç³ŠåŒ¹é…

---

## ğŸ—ï¸ ç»¼åˆæ¶æ„è®¾è®¡

### ä¸‰å±‚è¯†åˆ«æ¶æ„

```
ç”¨æˆ·è¾“å…¥
    â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬ä¸€å±‚ï¼šå¿«é€Ÿè§„åˆ™åŒ¹é…ï¼ˆå›ºå®šæ¨¡å¼ï¼‰   â”‚
â”‚  - ç²¾ç¡®åŒ¹é…                    â”‚
â”‚  - æ­£åˆ™è¡¨è¾¾å¼                    â”‚
â”‚  - å‘½ä»¤å…³é”®è¯                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ åŒ¹é…æˆåŠŸ â†’ ç›´æ¥è¿”å›æ„å›¾
    â†“ åŒ¹é…å¤±è´¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬äºŒå±‚ï¼šä»£ç é€»è¾‘å¤„ç†ï¼ˆå¤æ‚é€»è¾‘ï¼‰   â”‚
â”‚  - çŠ¶æ€æ£€æŸ¥                    â”‚
â”‚  - ä¸Šä¸‹æ–‡åˆ†æ                    â”‚
â”‚  - å¤šæ¡ä»¶ç»„åˆ                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“ åŒ¹é…æˆåŠŸ â†’ ç›´æ¥è¿”å›æ„å›¾
    â†“ åŒ¹é…å¤±è´¥
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ç¬¬ä¸‰å±‚ï¼šå¤§æ¨¡å‹è¯­ä¹‰è¯†åˆ«ï¼ˆLLMï¼‰     â”‚
â”‚  - æ„å›¾åˆ†ç±»                    â”‚
â”‚  - å®ä½“æå–                    â”‚
â”‚  - å¤šæ„å›¾è¯†åˆ«                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â†“
è¿”å›è¯†åˆ«ç»“æœ
```

---

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è®¾è®¡

### 1. æ„å›¾è¯†åˆ«å™¨æ¥å£ï¼ˆIntentRecognizerï¼‰

```python
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from enum import Enum
from dataclasses import dataclass

class IntentType(Enum):
    """æ„å›¾ç±»å‹"""
    # å‘½ä»¤ç±»
    STATUS = "status"
    HELP = "help"
    EXIT = "exit"
    
    # ä»»åŠ¡ç±»
    CODE_ANALYSIS = "code_analysis"
    CODE_REFACTORING = "code_refactoring"
    CODE_FIX = "code_fix"
    
    # æµ‹è¯•ç±»
    TEST_GENERATION = "test_generation"
    TEST_FIX = "test_fix"
    
    # æ–‡æ¡£ç±»
    DOC_GENERATION = "doc_generation"
    DOC_UPDATE = "doc_update"
    
    # é¡¹ç›®ç®¡ç†ç±»
    PROJECT_ANALYSIS = "project_analysis"
    TASK_PLANNING = "task_planning"
    
    # æœªçŸ¥
    UNKNOWN = "unknown"

@dataclass
class Intent:
    """æ„å›¾"""
    type: IntentType  # æ„å›¾ç±»å‹
    confidence: float  # ç½®ä¿¡åº¦ 0-1
    parameters: Dict[str, Any]  # æ„å›¾å‚æ•°
    method: Optional[str] = None  # å¯¹åº”çš„æ–¹æ³•å
    metadata: Dict[str, Any] = None  # å…ƒæ•°æ®

class IntentRecognizer(ABC):
    """
    æ„å›¾è¯†åˆ«å™¨æ¥å£
    """
    
    @abstractmethod
    async def recognize(
        self,
        input_text: str,
        context: Optional[Dict] = None
    ) -> Optional[Intent]:
        """
        è¯†åˆ«æ„å›¾
        
        Args:
            input_text: ç”¨æˆ·è¾“å…¥
            context: ä¸Šä¸‹æ–‡ä¿¡æ¯
            
        Returns:
            è¯†åˆ«åˆ°çš„æ„å›¾ï¼Œå¦‚æœä¸åŒ¹é…è¿”å› None
        """
        pass
    
    @abstractmethod
    def get_priority(self) -> int:
        """
        è·å–è¯†åˆ«å™¨ä¼˜å…ˆçº§
        
        Returns:
            ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
        """
        pass
```

### 2. å›ºå®šæ¨¡å¼è¯†åˆ«å™¨ï¼ˆRuleBasedRecognizerï¼‰

```python
import re
from typing import Dict, Optional, List

class RuleBasedRecognizer(IntentRecognizer):
    """
    å›ºå®šè§„åˆ™è¯†åˆ«å™¨
    
    ç‰¹ç‚¹ï¼š
    - é€Ÿåº¦å¿«
    - å‡†ç¡®ç‡é«˜
    - é€‚åˆæ˜ç¡®å‘½ä»¤
    """
    
    def __init__(self, rules: List[Dict] = None):
        self.rules = rules or self._default_rules()
    
    def _default_rules(self) -> List[Dict]:
        """é»˜è®¤è§„åˆ™åˆ—è¡¨"""
        return [
            # çŠ¶æ€å‘½ä»¤
            {
                "name": "status",
                "intent": IntentType.STATUS,
                "patterns": [
                    r"^/status\s*$",
                    r"^çŠ¶æ€\s*$",
                    r"^æŸ¥çœ‹çŠ¶æ€\s*$"
                ],
                "method": "show_status"
            },
            # å¸®åŠ©å‘½ä»¤
            {
                "name": "help",
                "intent": IntentType.HELP,
                "patterns": [
                    r"^/help\s*$",
                    r"^/?help\s*$",
                    r"^å¸®åŠ©\s*$",
                    r"^/?\?$"
                ],
                "method": "show_help"
            },
            # é€€å‡ºå‘½ä»¤
            {
                "name": "exit",
                "intent": IntentType.EXIT,
                "patterns": [
                    r"^/exit\s*$",
                    r"^é€€å‡º\s*$",
                    r"^å†è§\s*$",
                    r"^quit\s*$"
                ],
                "method": "exit"
            },
            # ä»£ç åˆ†æå‘½ä»¤
            {
                "name": "code_analysis",
                "intent": IntentType.CODE_ANALYSIS,
                "patterns": [
                    r"^åˆ†æä»£ç \s*(?P<path>.*)",
                    r"^analyze\s+code\s*(?P<path>.*)",
                    r"^ä»£ç åˆ†æ\s*(?P<path>.*)",
                    r"^æ£€æŸ¥ä»£ç \s*(?P<path>.*)"
                ],
                "method": "analyze_code"
            },
            # æµ‹è¯•å‘½ä»¤
            {
                "name": "test_fix",
                "intent": IntentType.TEST_FIX,
                "patterns": [
                    r"^ä¿®å¤æµ‹è¯•\s*$",
                    r"^fix\s+tests?\s*$",
                    r"^æµ‹è¯•å¤±è´¥\s*$",
                    r"^run\s+tests?\s*$"
                ],
                "method": "fix_tests"
            }
        ]
    
    async def recognize(
        self,
        input_text: str,
        context: Optional[Dict] = None
    ) -> Optional[Intent]:
        """
        ä½¿ç”¨è§„åˆ™è¯†åˆ«æ„å›¾
        """
        input_lower = input_text.strip().lower()
        
        for rule in self.rules:
            for pattern in rule.get("patterns", []):
                match = re.match(pattern, input_lower)
                if match:
:
                    # æå–å‚æ•°
                    parameters = match.groupdict() if match.groupdict() else {}
                    
                    return Intent(
                        type=rule["intent"],
                        confidence=1.0,  # è§„åˆ™åŒ¹é…ç½®ä¿¡åº¦é«˜
                        parameters=parameters,
                        method=rule.get("method"),
                        metadata={"matched_pattern": pattern, "recognizer": "rule_based"}
                    )
        
        return None
    
    def get_priority(self) -> int:
        """å›ºå®šè§„åˆ™ä¼˜å…ˆçº§æœ€é«˜"""
        return 1
    
    def add_rule(self, rule: Dict):
        """æ·»åŠ æ–°è§„åˆ™"""
        self.rules.append(rule)
    
    def remove_rule(self, name: str):
        """ç§»é™¤è§„åˆ™"""
        self.rules = [r for r in self.rules if r.get("name") != name]
```

### 3. ä»£ç å¤„ç†è¯†åˆ«å™¨ï¼ˆCodeBasedRecognizerï¼‰

```python
class CodeBasedRecognizer(IntentRecognizer):
    """
    ä»£ç é€»è¾‘è¯†åˆ«å™¨
    
    ç‰¹ç‚¹ï¼š
    - æ”¯æŒå¤æ‚é€»è¾‘
    - çŠ¶æ€ä¾èµ–
    - ä¸Šä¸‹æ–‡æ„ŸçŸ¥
    """
    
    def __init__(self):
        self.handlers = {
            "check_git_status": self._check_git_status,
            "check_dependencies": self._check_dependencies,
            "check_running_tasks": self._check_running_tasks,
            "analyze_code_context": self._analyze_code_context
        }
    
    async def recognize(
        self,
        input_text: str,
        context: Optional[Dict] = None
    ) -> Optional[Intent]:
        """
        ä½¿ç”¨ä»£ç é€»è¾‘è¯†åˆ«æ„å›¾
        """
        # æ£€æŸ¥æ˜¯å¦åœ¨å·¥ä½œç›®å½•ä¸­
        if context and context.get("in_workspace"):
            # æ£€æŸ¥ git çŠ¶æ€
            intent = await self._check_git_status(input_text, context)
            if intent:
                return intent
            
            # æ£€æŸ¥ä¾èµ–
            intent = await self._check_dependencies(input_text, context)
            if intent:
                return intent
            
            # åˆ†æä»£ç ä¸Šä¸‹æ–‡
            intent = await self._analyze_code_context(input_text, context)
            if intent:
                return intent
        
        # æ£€æŸ¥è¿è¡Œä¸­çš„ä»»åŠ¡
        if context:
            intent = await self._check_running_tasks(input_text, context)
            if intent:
                return intent
        
        return None
    
    async def _check_git_status(
        self,
        input_text: str,
        context: Dict
    ) -> Optional[Intent]:
        """æ£€æŸ¥ git ç›¸å…³æ„å›¾"""
        keywords = ["git", "commit", "push", "pull", "branch", "merge"]
        
        if any(kw in input_text.lower() for kw in keywords):
            return Intent(
                type=IntentType.CODE_ANALYSIS,
                confidence=0.9,
                parameters={"action": "git"},
                method="handle_git_command",
                metadata={"recognizer": "code_based"}
            )
        
        return None
    
    async def _check_dependencies(
        self,
        input_text: str,
        context: Dict
    ) -> Optional[Intent]:
        """æ£€æŸ¥ä¾èµ–ç›¸å…³çš„æ„å›¾"""
        keywords = ["ä¾èµ–", "dependency", "install", "package", "pip", "npm"]
        
        if any(kw in input_text.lower() for kw in keywords):
            return Intent(
                type=IntentType.CODE_ANALYSIS,
                confidence=0.85,
                parameters={"action": "dependencies"},
                method="handle_dependencies",
                metadata={"recognizer": "code_based"}
            )
        
        return None
    
    async def _check_running_tasks(
        self,
        input_text: str,
        context: Dict
    ) -> Optional[Intent]:
        """æ£€æŸ¥è¿è¡Œä¸­çš„ä»»åŠ¡"""
        task_manager = context.get("task_manager")
        if not task_manager:
            return None
        
        running_tasks = await task_manager.get_running_tasks()
        if not running_tasks:
            return None
        
        keywords = ["è¿›åº¦", "status", "åœæ­¢", "cancel", "å–æ¶ˆ"]
        if any(kw in input_text.lower() for kw in keywords):
            return Intent(
                type=IntentType.PROJECT_ANALYSIS,
                confidence=0.9,
                parameters={"running_tasks": len(running_tasks)},
                method="handle_task_management",
                metadata={"recognizer": "code_based"}
            )
        
        return None
    
    async def _analyze_code_context(
        self,
        input_text: str,
        context: Dict
    ) -> Optional[Intent]:
        """åˆ†æä»£ç ä¸Šä¸‹æ–‡"""
        workspace = context.get("workspace")
        if not workspace:
            return None
        
        # æ£€æŸ¥æ˜¯å¦åœ¨ä»£ç ç›®å½•ä¸­
        from pathlib import Path
        
        workspace_path = Path(workspace)
        py_files = list(workspace_path.rglob("*.py"))
        js_files = list(workspace_path.rglob("*.js"))
        
        if py_files or js_files:
            # æ£€æµ‹åˆ°ä»£ç æ–‡ä»¶
            keywords = ["ä¼˜åŒ–", "é‡æ„", "refactor", "improve"]
            if any(kw in input_text.lower() for kw in keywords):
                return Intent(
                    type=IntentType.CODE_REFACTORING,
                    confidence=0.8,
                    parameters={
                        "language": "python" if py_files else "javascript",
                        "file_count": len(py_files) + len(js_files)
                    },
                    method="handle_code_refactoring",
                    metadata={"recognizer": "code_based"}
                )
        
        return None
    
    def get_priority(self) -> int:
        """ä»£ç é€»è¾‘ä¼˜å…ˆçº§ä¸­ç­‰"""
        return 2
```

### 4. å¤§æ¨¡å‹è¯†åˆ«å™¨ï¼ˆLLMRecognizerï¼‰

```python
from litellm import acompletion

class LLMRecognizer(IntentRecognizer):
    """
    å¤§æ¨¡å‹è¯†åˆ«å™¨
    
    ç‰¹ç‚¹ï¼š
    - è¯­ä¹‰ç†è§£
    - æ¨¡ç³ŠåŒ¹é…
    - å¤šæ„å›¾è¯†åˆ«
    """
    
    def __init__(self, model: str = "glm-4.7"):
        self.model = model
        self.intent_definitions = self._load_intent_definitions()
    
    def _load_intent_definitions(self) -> str:
        """åŠ è½½æ„å›¾å®šä¹‰"""
        return """
# æ„å›¾å®šä¹‰

## 1. ä»£ç ç›¸å…³

### code_analysisï¼ˆä»£ç åˆ†æï¼‰
ç”¨æˆ·æƒ³è¦åˆ†æä»£ç ã€æ£€æŸ¥ä»£ç è´¨é‡ã€ç†è§£ä»£ç ç»“æ„ã€‚

å…³é”®è¯ï¼šåˆ†æã€æ£€æŸ¥ã€ç†è§£ã€æŸ¥çœ‹ã€review

### code_refactoringï¼ˆä»£ç é‡æ„ï¼‰
ç”¨æˆ·æƒ³è¦ä¼˜åŒ–ä»£ç ã€æ”¹è¿›ä»£ç ç»“æ„ã€æå‡æ€§èƒ½ã€‚

å…³é”®è¯ï¼šé‡æ„ã€ä¼˜åŒ–ã€æ”¹è¿›ã€æå‡ã€refactor

### code_fixï¼ˆä»£ç ä¿®å¤ï¼‰
ç”¨æˆ·æƒ³è¦ä¿®å¤ä»£ç é”™è¯¯ã€è§£å†³é—®é¢˜ã€‚

å…³é”®è¯ï¼šä¿®å¤ã€è§£å†³ã€fixã€bugã€é”™è¯¯

## 2. æµ‹è¯•ç›¸å…³

### test_generationï¼ˆæµ‹è¯•ç”Ÿæˆï¼‰
ç”¨æˆ·æƒ³è¦ç”Ÿæˆæµ‹è¯•ç”¨ä¾‹ã€‚

å…³é”®è¯ï¼šç”Ÿæˆæµ‹è¯•ã€å†™æµ‹è¯•ã€test

### test_fixï¼ˆæµ‹è¯•ä¿®å¤ï¼‰
ç”¨æˆ·æƒ³è¦ä¿®å¤å¤±è´¥çš„æµ‹è¯•ã€‚

å…³é”®è¯ï¼šä¿®å¤æµ‹è¯•ã€æµ‹è¯•å¤±è´¥ã€test fail

## 3. æ–‡æ¡£ç›¸å…³

### doc_generationï¼ˆæ–‡æ¡£ç”Ÿæˆï¼‰
ç”¨æˆ·æƒ³è¦ç”Ÿæˆæ–‡æ¡£ã€ç¼–å†™è¯´æ˜ã€‚

å…³é”®è¯ï¼šç”Ÿæˆæ–‡æ¡£ã€å†™æ–‡æ¡£ã€æ–‡æ¡£ã€doc

### doc_updateï¼ˆæ–‡æ¡£æ›´æ–°ï¼‰
ç”¨æˆ·æƒ³è¦æ›´æ–°ç°æœ‰æ–‡æ¡£ã€‚

å…³é”®è¯ï¼šæ›´æ–°æ–‡æ¡£ã€ä¿®æ”¹æ–‡æ¡£ã€æ›´æ–°

## 4. é¡¹ç›®ç®¡ç†

### project_analysisï¼ˆé¡¹ç›®åˆ†æï¼‰
ç”¨æˆ·æƒ³è¦åˆ†ææ•´ä¸ªé¡¹ç›®ã€ç†è§£é¡¹ç›®ç»“æ„ã€‚

å…³é”®è¯ï¼šåˆ†æé¡¹ç›®ã€é¡¹ç›®ç»“æ„ã€é¡¹ç›®

### task_planningï¼ˆä»»åŠ¡è§„åˆ’ï¼‰
ç”¨æˆ·æƒ³è¦è§„åˆ’ä»»åŠ¡ã€åˆ¶å®šè®¡åˆ’ã€‚

å…³é”®è¯ï¼šè§„åˆ’ã€è®¡åˆ’ã€ä»»åŠ¡ã€todo

## 5. é€šç”¨

### statusï¼ˆçŠ¶æ€ï¼‰
ç”¨æˆ·æƒ³è¦æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€ã€è¿è¡Œæƒ…å†µã€‚

å…³é”®è¯ï¼šçŠ¶æ€ã€statusã€å¦‚ä½•

### helpï¼ˆå¸®åŠ©ï¼‰
ç”¨æˆ·æƒ³è¦è·å–å¸®åŠ©ä¿¡æ¯ã€‚

å…³é”®è¯ï¼šå¸®åŠ©ã€helpã€æ€ä¹ˆã€å¦‚ä½•

### unknownï¼ˆæœªçŸ¥ï¼‰
æ— æ³•æ˜ç¡®è¯†åˆ«çš„æ„å›¾ã€‚
"""
    
    async def recognize(
        self,
        input_text: str,
        context: Optional[Dict] = None
    ) -> Optional[Intent]:
        """
        ä½¿ç”¨å¤§æ¨¡å‹è¯†åˆ«æ„å›¾
        """
        # æ„å»ºæç¤ºè¯
        prompt = self._build_recognition_prompt(input_text, context)
        
        # è°ƒç”¨å¤§æ¨¡å‹
        response = await acompletion(
            model=self.model,
            messages=[
                {"role": "system", "content": self.intent_definitions},
                {"role": "user", "content": prompt}
            ],
            response_format={
                "type": "json_schema",
                "json_schema": {
                    "name": "intent_recognition",
                    "strict": True,
                    "schema": {
                        "type": "object",
                        "properties": {
                            "intent": {
                                "type": "string",
                                "enum": [
                                    "code_analysis",
                                    "code_refactoring",
                                    "code_fix",
                                    "test_generation",
                                    "test_fix",
                                    "doc_generation",
                                    "doc_update",
                                    "project_analysis",
                                    "task_planning",
                                    "status",
                                    "help",
                                    "unknown"
                                ]
                            },
                            "confidence": {
                                "type": "number",
                                "minimum": 0,
                                "maximum": 1
                            },
                            "parameters": {
                                "type": "object",
                                "properties": {
                                    "path": {"type": "string"},
                                    "language": {"type": "string"},
                                    "action": {"type": "string"}
                                }
                            },
                            "reasoning": {
                                "type": "string"
                            }
                        },
                        "required": ["intent", "confidence", "reasoning"]
                    }
                }
            },
            temperature=0.3  # ä½æ¸©åº¦ï¼Œæé«˜ç¡®å®šæ€§
        )
        
        # è§£æå“åº”
        import json
        result = json.loads(response.choices[0].message.content)
        
        # æ˜ å°„åˆ° IntentType
        intent_type_map = {
            "code_analysis": IntentType.CODE_ANALYSIS,
            "code_refactoring": IntentType.CODE_REFACTORING,
            "code_fix": IntentType.CODE_FIX,
            "test_generation": IntentType.TEST_GENERATION,
            "test_fix": IntentType.TEST_FIX,
            "doc_generation": IntentType.DOC_GENERATION,
            "doc_update": IntentType.DOC_UPDATE,
            "project_analysis": IntentType.PROJECT_ANALYSIS,
            "task_planning": IntentType.TASK_PLANNING,
            "status": IntentType.STATUS,
            "help": IntentType.HELP,
            "unknown": IntentType.UNKNOWN
        }
        
        return Intent(
            type=intent_type_map.get(result["intent"], IntentType.UNKNOWN),
            confidence=result["confidence"],
            parameters=result.get("parameters", {}),
            metadata={
                "reasoning": result.get("reasoning", ""),
                "recognizer": "llm"
            }
        )
    
    def _build_recognition_prompt(
        self,
        input_text: str,
        context: Optional[Dict]
    ) -> str:
        """æ„å»ºè¯†åˆ«æç¤ºè¯"""
        prompt = f"""
è¯·è¯†åˆ«ä»¥ä¸‹ç”¨æˆ·è¾“å…¥çš„æ„å›¾ã€‚

ç”¨æˆ·è¾“å…¥ï¼š{input_text}
"""
        
        if context:
            prompt += f"""
ä¸Šä¸‹æ–‡ä¿¡æ¯ï¼š
- å·¥ä½œåŒºï¼š{context.get('workspace', 'N/A')}
- å½“å‰ç›®å½•ï¼š{context.get('current_dir', 'N/A')}
- è¿è¡Œä¸­ä»»åŠ¡æ•°ï¼š{len(context.get('running_tasks', []))}
"""
        
        prompt += """
è¯·ä»¥ JSON æ ¼å¼è¿”å›è¯†åˆ«ç»“æœï¼ŒåŒ…å«ï¼š
- intent: æ„å›¾ç±»å‹
- confidence: ç½®ä¿¡åº¦ï¼ˆ0-1ï¼‰
- parameters: æå–çš„å‚æ•°ï¼ˆå¦‚æœæœ‰ï¼‰
- reasoning: è¯†åˆ«ç†ç”±
"""
        return prompt
    
    def get_priority(self) -> int:
        """å¤§æ¨¡å‹è¯†åˆ«ä¼˜å…ˆçº§æœ€ä½ï¼ˆä½†åŠŸèƒ½æœ€å¼ºï¼‰"""
        return 3
```

### 5. ç»¼åˆè¯†åˆ«å™¨ï¼ˆHybridIntentRecognizerï¼‰

```python
import logging
from typing import List, Optional

class HybridIntentRecognizer:
    """
    ç»¼åˆæ„å›¾è¯†åˆ«å™¨
    
    æŒ‰ä¼˜å…ˆçº§ä¾æ¬¡å°è¯•ä¸åŒçš„è¯†åˆ«å™¨ï¼š
    1. å›ºå®šè§„åˆ™ï¼ˆä¼˜å…ˆçº§ 1ï¼‰- å¿«é€Ÿã€å‡†ç¡®
    2. ä»£ç é€»è¾‘ï¼ˆä¼˜å…ˆçº§ 2ï¼‰- å¤æ‚ã€ä¸Šä¸‹æ–‡
    3. å¤§æ¨¡å‹ï¼ˆä¼˜å…ˆçº§ 3ï¼‰- è¯­ä¹‰ç†è§£ã€æ¨¡ç³Š
    """
    
    def __init__(
        self,
        recognizers: List[IntentRecognizer] = None,
        enable_fallback: bool = True,
        log_decisions: bool = True
    ):
        """
        åˆå§‹åŒ–ç»¼åˆè¯†åˆ«å™¨
        
        Args:
            recognizers: è¯†åˆ«å™¨åˆ—è¡¨ï¼ˆæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
            enable_fallback: æ˜¯å¦å¯ç”¨é™çº§ç­–ç•¥
            log_decisions: æ˜¯å¦è®°å½•å†³ç­–è¿‡ç¨‹
        """
        self.recognizers = recognizers or self._default_recognizers()
        self.enable_fallback = enable_fallback
        self.log_decisions = log_decisions
        self.logger = logging.getLogger(__name__)
        
        # ç»Ÿè®¡ä¿¡æ¯
        self.stats = {
            "total_recognitions": 0,
            "rule_based_matches": 0,
            "code_based_matches": 0,
            "llm_based_matches": 0,
            "no_match": 0
        }
    
    def _default_recognizers(self) -> List[IntentRecognizer]:
        """åˆ›å»ºé»˜è®¤è¯†åˆ«å™¨åˆ—è¡¨"""
        return [
            RuleBasedRecognizer(),  # ä¼˜å…ˆçº§ 1
            CodeBasedRecognizer(),  # ä¼˜å…ˆçº§ 2
            LLMRecognizer(model="glm-4.7")  # ä¼˜å…ˆçº§ 3
        ]
    
    async def recognize(
        self,
        input_text: str,
        context: Optional[Dict] = None
    ) -> Intent:
        """
        ç»¼åˆè¯†åˆ«æ„å›¾
        """
        self.stats["total_recognitions"] += 1
        
        self.logger.debug(f"Recognizing intent for: {input_text[:50]}...")
        
        # æŒ‰ä¼˜å…ˆçº§ä¾æ¬¡å°è¯•
        sorted_recognizers = sorted(
            self.recognizers,
            key=lambda r: r.get_priority()
        )
        
        for recognizer in sorted_recognizers:
            self.logger.debug(
                f"Trying recognizer: {recognizer.__class__.__name__}"
            )
            
            try:
                intent = await recognizer.recognize(input_text, context)
                
                if intent:
                    # è®°å½•ç»Ÿè®¡
                    recognizer_name = recognizer.__class__.__name__
                    if "RuleBased" in recognizer_name:
                        self.stats["rule_based_matches"] += 1
                    elif "CodeBased" in recognizer_name:
                        self.stats["code_based_matches"] += 1
                    elif "LLM" in recognizer_name:
                        self.stats["llm_based_matches"] += 1
                    
                    self.logger.info(
                        f"Intent recognized: {intent.type.value} "
                        f"(confidence: {intent.confidence:.2f}, "
                        f"recognizer: {recognizer_name})"
                    )
                    
                    return intent
            
            except Exception as e:
                self.logger.error(
                    f"Recognizer {recognizer.__class__.__name__} failed: {e}",
                    exc_info=True
                )
                
                if not self.enable_fallback:
                    raise
        
        # æ²¡æœ‰åŒ¹é…çš„æ„å›¾
        self.stats["no_match"] += 1
        self.logger.warning(f"No intent matched for: {input_text}")
        
        return Intent(
            type=IntentType.UNKNOWN,
            confidence=0.0,
            parameters={},
            metadata={"recognizer": "none"}
        )
    
    def add_recognizer(self, recognizer: IntentRecognizer):
        """æ·»åŠ è¯†åˆ«å™¨"""
        self.recognizers.append(recognizer)
    
    def remove_recognizer(self, recognizer: IntentRecognizer):
        """ç§»é™¤è¯†åˆ«å™¨"""
        self.recognizers.remove(recognizer)
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total = self.stats["total_recognitions"]
        if total == 0:
            return self.stats.copy()
        
        stats = self.stats.copy()
        stats["rule_based_rate"] = stats["rule_based_matches"] / total
        stats["code_based_rate"] = stats["code_based_matches"] / total
        stats["llm_based_rate"] = stats["llm_based_matches"] / total
        stats["no_match_rate"] = stats["no_match"] / total
        
        return stats
```

---

## ğŸ¨ ä½¿ç”¨ç¤ºä¾‹

### ç¤ºä¾‹ 1ï¼šåŸºæœ¬ä½¿ç”¨

```python
# åˆ›å»ºç»¼åˆè¯†åˆ«å™¨
recognizer = HybridIntentRecognizer()

# è¯†åˆ«æ„å›¾
intent = await recognizer.recognize(
    "åˆ†æè¿™ä¸ªé¡¹ç›®çš„ä»£ç è´¨é‡",
    context={
        "workspace": "/path/to/project",
        "current_dir": "/path/to/project/src",
        "running_tasks": []
    }
)

print(f"Intent: {intent.type.value}")
print(f"Confidence: {intent.confidence}")
print(f"Parameters: {intent.parameters}")
print(f"Method: {intent.method}")
```

### ç¤ºä¾‹ 2ï¼šè‡ªå®šä¹‰è§„åˆ™

```python
# åˆ›å»ºè§„åˆ™è¯†åˆ«å™¨
rule_recognizer = RuleBasedRecognizer()

# æ·»åŠ è‡ªå®šä¹‰è§„åˆ™
rule_recognizer.add_rule({
    "name": "deploy",
    "intent": IntentTypeType.PROJECT_ANALYSIS,
    "patterns": [
        r"^éƒ¨ç½²\s+(?P<env>.+)",
        r"^deploy\s+(?P<env>.+)"
    ],
    "method": "deploy_to_environment"
})

# åˆ›å»ºç»¼åˆè¯†åˆ«å™¨
recognizer = HybridIntentRecognizer(recognizers=[rule_recognizer])
```

### ç¤ºä¾‹ 3ï¼šè‡ªå®šä¹‰ä»£ç é€»è¾‘

```python
# åˆ›å»ºä»£ç é€»è¾‘è¯†åˆ«å™¨
code_recognizer = CodeBasedRecognizer()

# æ·»åŠ è‡ªå®šä¹‰å¤„ç†å‡½æ•°
async def check_custom_logic(input_text: str, context: Dict) -> Optional[Intent]:
    if "ç‰¹æ®Šä»»åŠ¡" in input_text:
        return Intent(
            type=IntentType.TASK_PLANNING,
            confidence=0.95,
            parameters={"custom": True},
            method="handle_custom_task"
        )
    return None

code_recognizer.handlers["custom_logic"] = check_custom_logic

# åˆ›å»ºç»¼åˆè¯†åˆ«å™¨
recognizer = HybridIntentRecognizer(recognizers=[code_recognizer])
```

---

## ğŸ“Š æ€§èƒ½åˆ†æ

### ä¸‰å±‚è¯†åˆ«æ€§èƒ½å¯¹æ¯”

| è¯†åˆ«å™¨ | é€Ÿåº¦ | å‡†ç¡®ç‡ | é€‚ç”¨åœºæ™¯ | ä¼˜å…ˆçº§ |
|--------|------|--------|---------|--------|
| å›ºå®šè§„åˆ™ | âš¡âš¡âš¡ æå¿« | â­â­â­â­â­ ç²¾ç¡® | æ˜ç¡®å‘½ä»¤ã€å…³é”®è¯ | 1 |
| ä»£ç é€»è¾‘ | âš¡âš¡ å¿« | â­â­â­â­ é«˜ | å¤æ‚é€»è¾‘ã€çŠ¶æ€ä¾èµ– | 2 |
| å¤§æ¨¡å‹ | âš¡ æ…¢ | â­â­â­â­ ä¸­ | è¯­ä¹‰ç†è§£ã€æ¨¡ç³ŠåŒ¹é… | 3 |

### å®é™…æ€§èƒ½ç¤ºä¾‹

```
å›ºå®šè§„åˆ™åŒ¹é…ï¼š
- è¾“å…¥ï¼š"æŸ¥çœ‹çŠ¶æ€"
- è€—æ—¶ï¼š1ms
- ç½®ä¿¡åº¦ï¼š1.0
- åŒ¹é…å™¨ï¼šRuleBasedRecognizer

ä»£ç é€»è¾‘åŒ¹é…ï¼š
- è¾“å…¥ï¼š"æ£€æŸ¥ git çŠ¶æ€"ï¼ˆåœ¨ workspace ä¸­ï¼‰
- è€—æ—¶ï¼š5ms
- ç½®ä¿¡åº¦ï¼š0.9
- åŒ¹é…å™¨ï¼šCodeBasedRecognizer

å¤§æ¨¡å‹åŒ¹é…ï¼š
- è¾“å…¥ï¼š"è¿™ä¸ªä»£ç çœ‹èµ·æ¥æœ‰ç‚¹ä¹±ï¼Œèƒ½å¸®æˆ‘ä¼˜åŒ–ä¸€ä¸‹å—ï¼Ÿ"
- è€—æ—¶ï¼š800ms
- ç½®ä¿¡åº¦ï¼š0.85
- åŒ¹é…å™¨ï¼šLLMRecognizer
```

---

## ğŸ”§ é›†æˆåˆ° Gateway

### ä¿®æ”¹åçš„ Gateway ç±»

```python
class Gateway:
    """
    Gateway é›†æˆç»¼åˆæ„å›¾è¯†åˆ«
    """
    
    def __init__(self, config):
        self.config = config
        self.intent_recognizer = HybridIntentRecognizer()
        self.main_agent = None
    
    async def handle_message(self, message: str) -> str:
        """
        å¤„ç†ç”¨æˆ·æ¶ˆæ¯
        """
        # è¯†åˆ«æ„å›¾
        context = self._build_context()
        intent = await self.intent_recognizer.recognize(message, context)
        
        # æ ¹æ®æ„å›¾æ‰§è¡Œ
        if intent.type == IntentType.STATUS:
            return await self._handle_status(intent)
        elif intent.type == IntentType.HELP:
            return await self._handle_help(intent)
        elif intent.type == IntentType.CODE_ANALYSIS:
            return await self._handle_code_analysis(intent)
        elif intent.type == IntentType.TEST_FIX:
            return await self._handle_test_fix(intent)
        elif intent.type == IntentType.UNKNOWN:
            # æœªçŸ¥æ„å›¾ï¼Œäº¤ç»™ MainAgent å¤„ç†
            return await self.main_agent.process_message(message)
        else:
            # å…¶ä»–æ„å›¾ä¹Ÿäº¤ç»™ MainAgent
            return await self.main_agent.process_message(message)
    
    def _build_context(self) -> Dict:
        """æ„å»ºä¸Šä¸‹æ–‡"""
        return {
            "workspace": self.config.get("workspace"),
            "current_dir": os.getcwd(),
            "running_tasks": self._get_running_tasks(),
            "in_workspace": self._is_in_workspace()
        }
```

---

## âœ… å®æ–½æ£€æŸ¥æ¸…å•

### æ ¸å¿ƒç»„ä»¶
- [ ] å®ç° IntentType æšä¸¾
- [ ] å®ç° Intent æ•°æ®ç±»
- [ ] å®ç° IntentRecognizer æ¥å£

### è¯†åˆ«å™¨å®ç°
- [ ] å®ç° RuleBasedRecognizer
- [ ] å®ç° CodeBasedRecognizer
- [ ] å®ç° LLMRecognizer
- [ ] å®ç° HybridIntentRecognizer

### é…ç½®æ”¯æŒ
- [ ] æ”¯æŒè‡ªå®šä¹‰è§„åˆ™
- [ ] æ”¯æŒå¯ç”¨/ç¦ç”¨è¯†åˆ«å™¨
- [ ] æ”¯æŒè°ƒæ•´ä¼˜å…ˆçº§
- [ ] æ”¯æŒå¤§æ¨¡å‹é€‰æ‹©

### é›†æˆæµ‹è¯•
- [ ] é›†æˆåˆ° Gateway
- [ ] æµ‹è¯•å›ºå®šè§„åˆ™åŒ¹é…
- [ ] æµ‹è¯•ä»£ç é€»è¾‘åŒ¹é…
- [ ] æµ‹è¯•å¤§æ¨¡å‹åŒ¹é…
- [ ] æµ‹è¯•ç»¼åˆè¯†åˆ«æµç¨‹
- [ ] æµ‹è¯•æ€§èƒ½å’Œå‡†ç¡®ç‡

---

## ğŸ“ æ€»ç»“

ç»¼åˆæ„å›¾è¯†åˆ«ç³»ç»Ÿæä¾›äº†å¼ºå¤§è€Œçµæ´»çš„æ„å›¾è¯†åˆ«èƒ½åŠ›ï¼š

âœ… **ä¸‰å±‚æ¶æ„** - å›ºå®šè§„åˆ™ â†’ ä»£ç é€»è¾‘ â†’ å¤§æ¨¡å‹
âœ… **ä¼˜å…ˆçº§æœºåˆ¶** - å¿«é€ŸåŒ¹é…ä¼˜å…ˆï¼Œè¯­ä¹‰ç†è§£é™çº§
âœ… **çµæ´»æ‰©å±•** - æ”¯æŒè‡ªå®šä¹‰è§„åˆ™å’Œé€»è¾‘
âœ… **ä¸Šä¸‹æ–‡æ„ŸçŸ¥** - è€ƒè™‘å½“å‰çŠ¶æ€å’Œç¯å¢ƒ
âœ… **æ€§èƒ½ä¼˜åŒ–** - è§„åˆ™åŒ¹é…æå¿«ï¼Œå¤§æ¨¡å‹å…œåº•
âœ… **å‡†ç¡®å¯é ** - å¤šå±‚éªŒè¯ï¼Œæé«˜è¯†åˆ«å‡†ç¡®ç‡

é€šè¿‡è¿™ä¸ªç³»ç»Ÿï¼ŒNanobot å¯ä»¥ï¼š
- å¿«é€Ÿè¯†åˆ«æ˜ç¡®å‘½ä»¤ï¼ˆè§„åˆ™åŒ¹é…ï¼‰
- å¤„ç†å¤æ‚åœºæ™¯ï¼ˆä»£ç é€»è¾‘ï¼‰
- ç†è§£æ¨¡ç³Šè¾“å…¥ï¼ˆå¤§æ¨¡å‹ï¼‰
- åŠ¨æ€æ‰©å±•æ–°æ„å›¾ï¼ˆé…ç½®é©±åŠ¨ï¼‰
