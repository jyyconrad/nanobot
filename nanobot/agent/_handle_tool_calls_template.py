#!/usr/bin/env python3
"""生成修复后的 _handle_tool_calls 方法"""
print("""
# 生成修复后的 _handle_tool_calls 方法

print("async def _handle_tool_calls(self, response: Any, messages: List[Dict[str, Any]]) -> str:")
print('    """')
print('        处理工具调用的完整循环')
print('')
print('        Args:')
print('            response: LLM 响应对象')
print('            messages: 当前消息列表')
print('')
print('        Returns:')
print('            最终响应给用户的文本')
print('        """')
print('        logger.info(f"MainAgent[{self.session_id}] 处理工具调用：{len(response.tool_calls)} 个")')
print()
print('        # 执行工具调用循环')
print('        max_iterations = 10  # 防止无限循环')
print('        current_messages = messages.copy()')
print('        assistant_message = ""')
print()
print('        for iteration in range(max_iterations):')
print('            if not response.has_tool_calls:')
print('                # 没有工具调用，返回最终响应')
print('                logger.debug(f"MainAgent[{self.session_id}] 第 {iteration+1} 轮迭代：无工具调用")')
print('                break')
print('            ')
print('            logger.info(f"MainAgent[{self.session_id}] 第 {iteration+1} 轮迭代：执行工具")')
print('            ')
print('            # 处理每个工具调用')
print('            tool_results = []')
print('            for tool_call in response.tool_calls:')
print('                logger.debug(f"MainAgent[{self.session_id}]   调用工具：{tool_call.name}")')
print('                ')
print('                try:')
print('                    # 获取工具实例')
print('                    if self.agent_loop and hasattr(self.agent_loop, "tools"):')
print('                        tool = self.agent_loop.tools.get(tool_call.name)')
print('                        if tool:')
print('                            logger.info(f"MainAgent[{self.session_id}]   执行工具：{tool_call.name}")')
print('                            ')
print('                            # 解析工具参数')
print('                            args = tool_call.arguments')
print('                            logger.debug(f"MainAgent[{self.session_id}]     - 参数类型: {type(args).__name__}")')
print('                            ')
print('                            # 执行工具')
print('                            if hasattr(tool, "execute") and asyncio.iscoroutine(tool.execute):')
print('                                tool_result = await tool.execute(args)')
print('                                logger.debug(f"MainAgent[{self.session_id}]   - 工具结果：{str(tool_result)[:100]}")
print('                            else:')
print('                                # 同步执行')
print('                                tool_result = tool.execute(args)')
print('                                logger.debug(f"MainAgent[{self.session_id}]   - 工具结果：{str(tool_result)[:100]}")')
print('                            ')
print('                            # 记录结果')
print('                            tool_results.append({')
print('                                "tool": tool_call.name,')
print('                                "result": tool_result')
print('                            })')
print('                        else:')
print('                            logger.warning(f"MainAgent[{self.session_id}]   工具未找到：{tool_call.name}")')
print('                            tool_results.append({')
print('                                "tool": tool_call.name,')
print('                                "result": f"工具未找到：{tool_call.name}"')
print('                            })')
print('                    else:')
print('                        logger.warning(f"MainAgent[{self.session_id}]   没有工具注册表")')
print('                        tool_results.append({')
print('                            "tool": tool_call.name,')
print('                            "result": "工具系统不可用"')
print('                            })')
print('                except Exception as e:')
print('                    logger.error(f"MainAgent[{self.session_id}]   工具执行失败：{e}", exc_info=True)')
print('                    tool_results.append({')
print('                        "tool": tool_call.name,')
print('                        "result": f"执行失败：{str(e)}")
print('                            })')
print('            ')
print('            # 构建工具结果消息')
print('            if tool_results:')
print('                tool_result_messages = []')
print('                for result in tool_results:')
print('                    tool_result_messages.append(f"工具 {result['tool']}: {result['result']}")
print('                assistant_message = "\\n".join(tool_result_messages)')
print('                logger.info(f"MainAgent[{self.session_id}]   工具执行结果：{assistant_message[:200]}")')
print('            ')
print('            # 添加助手响应到消息历史')
print('            current_messages.append({')
print('                "role": "assistant",')
print('                "content": assistant_message')
print('            })')
print('            ')
print('            # 再次调用 LLM 处理工具结果')
print('            logger.info(f"MainAgent[{self.session_id}]   调用 LLM 处理工具结果")')
print('            ')
print('            try:')
print('                if self.agent_loop:')
print('                    provider = self.agent_loop.provider')
print('                    model = self.agent_loop.model')
print('                else:')
print('                    # Fallback for testing')
print('                    from nanobot.providers.litellm_provider import LiteLLMProvider')
print('                    provider = LiteLLMProvider()
print('                    model = "volcengine/glm-4.7"')
print('                ')
print('                response = await provider.chat(')
print('                    messages=current_messages,')
print('                    model=model,')
print('                    temperature=0.7')
print('                )')
print('            except Exception as e:')
print('                logger.error(f"MainAgent[{self.session_id}]   LLM 调用失败：{e}", exc_info=True)')
print('                assistant_message += f"\\n\\nLLM 调用出错：{str(e)}"')
print('                break')
print('        ')
print('        # 返回最终响应')
print('        return assistant_message or "工具调用完成"')
print('')